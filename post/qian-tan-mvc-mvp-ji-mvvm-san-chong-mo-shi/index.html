<html>
  <head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>浅谈MVC MVP及MVVM三种模式 | 夜雨、听风</title>
<link rel="shortcut icon" href="https://yeyusky.github.io/favicon.ico?v=1563242248496">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://yeyusky.github.io/styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>



  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://yeyusky.github.io">
  <img class="avatar" src="https://yeyusky.github.io/images/avatar.png?v=1563242248496" alt="">
  </a>
  <h1 class="site-title">
    夜雨、听风
  </h1>
  <p class="site-description">
    when you feel  unhappy ,look at the sky!
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="https://yeyusky.github.io/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>


        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              浅谈MVC MVP及MVVM三种模式
            </h2>
            <div class="post-info">
              <time class="post-time">
                · 2019-07-12 ·
              </time>
              
            </div>
            
              <div class="post-feature-image" style="background-image: url('https://yeyusky.github.io/post-images/qian-tan-mvc-mvp-ji-mvvm-san-chong-mo-shi.jpg')">
              </div>
            
            <div class="post-content">
              <h1>一、MVC</h1>
<p style="text-indent:2em;">MVC是Model-View-Controller的缩写，1、Model指模型（用于封装与应用程序的业务逻辑相关的数据以及对数据的处理方法）；2、View指视图（渲染页面）；3、Controller指控制器（Model和View之间的连接器，用于控制应用程序的流程，及页面的业务逻辑）。</p>
<h3>MVC特点</h3>
<p style="text-indent:2em;">MVC模式的特点在于实现关注点分离，即应用程序中的数据模型与业务和展示逻辑解耦。在客户端web开发中，就是将模型(M-数据、操作数据)、视图(V-显示数据的HTML元素)之间实现代码分离，松散耦合，使之成为一个更容易开发、维护和测试的客户端应用程序。</p>
<h3>MVC优点</h3>
<p>****耦合性低，视图层和业务层分离，这样就允许更改视图层代码而不用重新编译模型和控制器代码。</p>
<p>****重用性高。</p>
<p>****生命周期成本低。</p>
<p>****MVC使开发和维护用户接口的技术含量降低。</p>
<p>****可维护性高，分离视图层和业务逻辑层也使得WEB应用更易于维护和修改。</p>
<p>****部署快。</p>
<h3>MVC缺点</h3>
<p>****不适合小型，中等规模的应用程序，花费大量时间将MVC应用到规模并不是很大的应用程序通常会得不偿失。</p>
<p>****视图与控制器间过于紧密连接，视图与控制器是相互分离，但却是联系紧密的部件，视图没有控制器的存在，其应用是很有限的，反之亦然，这样就妨碍了他们的独立重用。</p>
<p>****视图对模型数据的低效率访问，依据模型操作接口的不同，视图可能需要多次调用才能获得足够的显示数据。对未变化数据的不必要的频繁访问，也将损害操作性能。</p>
<h3>MVC两种模式</h3>
<img src="https://yeyusky.github.io/post-images/mvc1.png" alt="" />
<img src="https://yeyusky.github.io/post-images/mvc2.png" alt="" />
<h1>二、MVP</h1>
<p style="text-indent:2em;">MVP（Model-View-Presenter）是MVC的改良版，1、Model指模型（用于封装与应用程序的业务逻辑相关的数据以及对数据的处理方法）；2、View指视图（渲染页面）；3、Controller改为 Presenter，同时改变了通信方向。（用于控制应用程序的流程，及页面的业务逻辑）。</p>
<h3>MVP特点</h3>
<p style="text-indent:2em;">Model、View、Presenter之间双向通信；View 与 Model 不通信，都通过 Presenter 传递，Presenter完全把Model和View进行了分离，主要的程序逻辑在Presenter里实现；View 非常薄，不部署任何业务逻辑，称为”被动视图”（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里；Presenter与具体的View是没有直接关联的，而是通过定义好的接口进行交互，从而使得在变更View时候可以保持Presenter的不变，这样就可以重用。不仅如此，还可以编写测试用的View，模拟用户的各种操作，从而实现对Presenter的测试，从而不需要使用自动化的测试工具。</p>
<p style="text-indent:2em;">区别：在MVP中，View并不直接使用Model，它们之间的通信是通过Presenter (MVC中的Controller)来进行的，所有的交互都发生在Presenter内部。在MVC中，View会直接从Model中读取数据而不是通过 Controller。</p>
<h3>MVP优点</h3>
<p>****模型与视图完全分离，我们可以修改视图而不影响模型。</p>
<p>****可以更高效地使用模型，因为所有的交互都发生在一个地方——Presenter内部。</p>
<p>****我们可以将一个Presenter用于多个视图，而不需要改变Presenter的逻辑。这个特性非常的有用，因为视图的变化总是比模型的变化频繁。</p>
<p>****如果我们把逻辑放在Presenter中，那么我们就可以脱离用户接口来测试这些逻辑。</p>
<h3>MVP缺点</h3>
<p>****视图和Presenter的交互会过于频繁，使得他们的联系过于紧密。也就是说，一旦视图变更了，presenter也要变更。</p>
<h3>MVP模式</h3>
<img src="https://yeyusky.github.io/post-images/mvp.png" alt="" />
<h1>三、MVVM</h1>
<p style="text-indent:2em;">MVVM是Model-View-ViewModel的缩写，1、Model模型是指代表真实状态内容的领域模型（面向对象），或指代表内容的数据访问层（以数据为中心）；2、View视图就像在MVC和MVP模式中一样，视图是用户在屏幕上看到的结构、布局和外观（UI）；3、ViewModel视图模型
视图模型是暴露公共属性和命令的视图的抽象。MVVM没有MVC模式的控制器，也没有MVP模式的presenter，有的是一个绑定器。在视图模型中，绑定器在视图和数据绑定器之间进行通信。它立足于原有MVP框架并且把微软WPF技术的新特性糅合进去，以应对客户日益复杂的需求变化。</p>
<h3>MVVM优点</h3>
<p>****低耦合，视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的“View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。</p>
<p>****可重用性，可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。</p>
<p>****独立开发，开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计，使用Expression Blend可以很容易设计界面并生成xml代码。</p>
<p>****可测试，界面向来是比较难于测试的，而现在测试可以针对ViewModel来写。</p>
<h3>MVVM缺点</h3>
<p>****来自MVVM的创造者John Gossman本人指出：实现MVVM的开销对于简单的UI操作是“过度的”。他说，对于更大的应用来说，推广ViewModel变得更加困难。而且，他说明了非常大的应用程序中的数据绑定会导致相当大的内存消耗。</p>
<h3>MVVM模式</h3>
<img src="https://yeyusky.github.io/post-images/mvvm.png" alt="" />
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://yeyusky.github.io/post/vue-xue-xi-zong-jie-vue-shi-li">
              <h3 class="post-title">
                Vue学习总结--vue实例
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '8b0323fee039a79581e3',
    clientSecret: '4bbb39c70431fc495ca2f696013267611696999c',
    repo: 'yeyusky.github.io',
    owner: 'yeyusky',
    admin: ['yeyusky'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://yeyusky.github.io/atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

      </div>
    </div>
  </body>
</html>
