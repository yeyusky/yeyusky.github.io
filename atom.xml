<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yeyusky.github.io</id>
    <title>夜雨、听风</title>
    <updated>2019-07-12T04:59:54.447Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yeyusky.github.io"/>
    <link rel="self" href="https://yeyusky.github.io/atom.xml"/>
    <subtitle>when you feel  unhappy ,look at the sky!</subtitle>
    <logo>https://yeyusky.github.io/images/avatar.png</logo>
    <icon>https://yeyusky.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, 夜雨、听风</rights>
    <entry>
        <title type="html"><![CDATA[浅谈MVC MVP及MVVM三种模式]]></title>
        <id>https://yeyusky.github.io/post/qian-tan-mvc-mvp-ji-mvvm-san-chong-mo-shi</id>
        <link href="https://yeyusky.github.io/post/qian-tan-mvc-mvp-ji-mvvm-san-chong-mo-shi">
        </link>
        <updated>2019-07-12T04:12:04.000Z</updated>
        <content type="html"><![CDATA[<h1>一、MVC</h1>
<p style="text-indent:2em;">MVC是Model-View-Controller的缩写，1、Model指模型（用于封装与应用程序的业务逻辑相关的数据以及对数据的处理方法）；2、View指视图（渲染页面）；3、Controller指控制器（Model和View之间的连接器，用于控制应用程序的流程，及页面的业务逻辑）。</p>
<h3>MVC特点</h3>
<p style="text-indent:2em;">MVC模式的特点在于实现关注点分离，即应用程序中的数据模型与业务和展示逻辑解耦。在客户端web开发中，就是将模型(M-数据、操作数据)、视图(V-显示数据的HTML元素)之间实现代码分离，松散耦合，使之成为一个更容易开发、维护和测试的客户端应用程序。</p>
<h3>MVC优点</h3>
<p>****耦合性低，视图层和业务层分离，这样就允许更改视图层代码而不用重新编译模型和控制器代码。</p>
<p>****重用性高。</p>
<p>****生命周期成本低。</p>
<p>****MVC使开发和维护用户接口的技术含量降低。</p>
<p>****可维护性高，分离视图层和业务逻辑层也使得WEB应用更易于维护和修改。</p>
<p>****部署快。</p>
<h3>MVC缺点</h3>
<p>****不适合小型，中等规模的应用程序，花费大量时间将MVC应用到规模并不是很大的应用程序通常会得不偿失。</p>
<p>****视图与控制器间过于紧密连接，视图与控制器是相互分离，但却是联系紧密的部件，视图没有控制器的存在，其应用是很有限的，反之亦然，这样就妨碍了他们的独立重用。</p>
<p>****视图对模型数据的低效率访问，依据模型操作接口的不同，视图可能需要多次调用才能获得足够的显示数据。对未变化数据的不必要的频繁访问，也将损害操作性能。</p>
<h3>MVC两种模式</h3>
<img src="https://yeyusky.github.io/post-images/mvc1.png" alt="" />
<img src="https://yeyusky.github.io/post-images/mvc2.png" alt="" />
<h1>二、MVP</h1>
<p style="text-indent:2em;">MVP（Model-View-Presenter）是MVC的改良版，1、Model指模型（用于封装与应用程序的业务逻辑相关的数据以及对数据的处理方法）；2、View指视图（渲染页面）；3、Controller改为 Presenter，同时改变了通信方向。（用于控制应用程序的流程，及页面的业务逻辑）。</p>
<h3>MVP特点</h3>
<p style="text-indent:2em;">Model、View、Presenter之间双向通信；View 与 Model 不通信，都通过 Presenter 传递，Presenter完全把Model和View进行了分离，主要的程序逻辑在Presenter里实现；View 非常薄，不部署任何业务逻辑，称为”被动视图”（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里；Presenter与具体的View是没有直接关联的，而是通过定义好的接口进行交互，从而使得在变更View时候可以保持Presenter的不变，这样就可以重用。不仅如此，还可以编写测试用的View，模拟用户的各种操作，从而实现对Presenter的测试，从而不需要使用自动化的测试工具。</p>
<p style="text-indent:2em;">区别：在MVP中，View并不直接使用Model，它们之间的通信是通过Presenter (MVC中的Controller)来进行的，所有的交互都发生在Presenter内部。在MVC中，View会直接从Model中读取数据而不是通过 Controller。</p>
<h3>MVP优点</h3>
<p>****模型与视图完全分离，我们可以修改视图而不影响模型。</p>
<p>****可以更高效地使用模型，因为所有的交互都发生在一个地方——Presenter内部。</p>
<p>****我们可以将一个Presenter用于多个视图，而不需要改变Presenter的逻辑。这个特性非常的有用，因为视图的变化总是比模型的变化频繁。</p>
<p>****如果我们把逻辑放在Presenter中，那么我们就可以脱离用户接口来测试这些逻辑。</p>
<h3>MVP缺点</h3>
<p>****视图和Presenter的交互会过于频繁，使得他们的联系过于紧密。也就是说，一旦视图变更了，presenter也要变更。</p>
<h3>MVP模式</h3>
<img src="https://yeyusky.github.io/post-images/mvp.png" alt="" />
<h1>三、MVVM</h1>
<p style="text-indent:2em;">MVVM是Model-View-ViewModel的缩写，1、Model模型是指代表真实状态内容的领域模型（面向对象），或指代表内容的数据访问层（以数据为中心）；2、View视图就像在MVC和MVP模式中一样，视图是用户在屏幕上看到的结构、布局和外观（UI）；3、ViewModel视图模型
视图模型是暴露公共属性和命令的视图的抽象。MVVM没有MVC模式的控制器，也没有MVP模式的presenter，有的是一个绑定器。在视图模型中，绑定器在视图和数据绑定器之间进行通信。它立足于原有MVP框架并且把微软WPF技术的新特性糅合进去，以应对客户日益复杂的需求变化。</p>
<h3>MVVM优点</h3>
<p>****低耦合，视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的“View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。</p>
<p>****可重用性，可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。</p>
<p>****独立开发，开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计，使用Expression Blend可以很容易设计界面并生成xml代码。</p>
<p>****可测试，界面向来是比较难于测试的，而现在测试可以针对ViewModel来写。</p>
<h3>MVVM缺点</h3>
<p>****来自MVVM的创造者John Gossman本人指出：实现MVVM的开销对于简单的UI操作是“过度的”。他说，对于更大的应用来说，推广ViewModel变得更加困难。而且，他说明了非常大的应用程序中的数据绑定会导致相当大的内存消耗。</p>
<h3>MVVM模式</h3>
<img src="https://yeyusky.github.io/post-images/mvvm.png" alt="" />]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue学习总结--vue实例]]></title>
        <id>https://yeyusky.github.io/post/vue-xue-xi-zong-jie-vue-shi-li</id>
        <link href="https://yeyusky.github.io/post/vue-xue-xi-zong-jie-vue-shi-li">
        </link>
        <updated>2019-07-05T04:16:12.000Z</updated>
        <content type="html"><![CDATA[<h1>一、vue的实例与数据</h1>
<p style="text-indent:2em;">让我们看一个最简单的实例，如下图：</p>
<img src="https://yeyusky.github.io/post-images/vuesl.png" alt="" />
<p style="text-indent:2em; font-size:12px;">如上图所示的实例，变量vm就代表了这个vue实例，我们这样就建好了一个vue实例，我们可以在实例里面添加内容（选项），从而让我们所想的渲染到页面上</p>
<h3>1、el</h3>
<p style="text-indent:2em;">必不可少的的一个选项就是el（挂载点），el用于指点一个页面中的DOM元素来挂载这个实例，如下图所示：</p>
<img src="https://yeyusky.github.io/post-images/vueel.png" alt="" />
<p style="text-indent:2em; font-size:12px;">这样我们就把一个实例挂载到了页面中存在的dom元素上</p>
<h3>2、data</h3>
<p style="text-indent:2em;">下面让我们来看另一个选项，data选项，data选项里面的属性（也就是数据），实例本身也代理data里面的属性，SO，我们可以把这些数据渲染到页面中，如下图：</p>
<img src="https://yeyusky.github.io/post-images/vuedata.png" alt="" />
<p style="text-indent:2em;">页面中是这个样的，如下图：</p>
<img src="https://yeyusky.github.io/post-images/vuedatah.png" alt="" />
<h3>3、props</h3>
<p style="text-indent:2em;">第三个选项是props，用于接收来自父组件的数据。因为组件实例的作用域是孤立的。这意味着不能在子组件的模板内直接引用父组件的数据。要让子组件使用父组件的数据，我们需要通过子组件的 props 选项。如下图所示：</p>
<img src="https://yeyusky.github.io/post-images/vueprops.png" alt="" />
<h3>4、Computed</h3>
<p style="text-indent:2em;">第四个选项是Computed（计算属性）<br>********1、我们可以像绑定普通属性一样在模板中绑定计算属性。<br>********2、计算属性是基于它们的依赖进行缓存的。也就是说，计算属性只有在它的相关依赖发生改变时才会重新求值。如果data中的属性值未发生变化，执行总会返回之前执行的结果。<br>********3、每当触发重新渲染时，调用方法将总会再次执行函数。</p>
<h3>5、methods</h3>
<p style="text-indent:2em;">第五个选项是 methods（里面是一些function），我们可以直接通过 实例访问这些方法，或者在指令表达式中使用。如图：</p>
<img src="https://yeyusky.github.io/post-images/vuemethods.png" alt="" />
<img src="https://yeyusky.github.io/post-images/vuemethodsh.png" alt="" />
<h3>6、watch</h3>
<p style="text-indent:2em;">第六个选项是watch（侦听属性），我们可以通过 watch 来响应数据的变化，如下图：</p>
<img src="https://yeyusky.github.io/post-images/vuewatch.png" alt="" />
<img src="https://yeyusky.github.io/post-images/vuewatch1.png" alt="" />
<img src="https://yeyusky.github.io/post-images/vuewatch2.png" alt="" />
<h1>二、生命周期钩子</h1>
<p style="text-indent:2em;">首先让我们来看一下官网的生命周期图：</p>
<img src="https://yeyusky.github.io/post-images/vuesm.png" alt="" />
<p style="text-indent:2em;">让我们创建一个vue实例，来观察一下不同的生命周期阶段，钩子函数执行的状态</p>
<h3>1、beforeCreate</h3>
<p style="text-indent:2em;">创建前状态：</p>
<img src="https://yeyusky.github.io/post-images/beforecreate.png" alt="" />
<img src="https://yeyusky.github.io/post-images/beforecreateh.png" alt="" />
<p style="text-indent:2em; font-size:12px;">如上图所示，未创建之前，el、data这些都是undefined。 </p>
<h3>2、Created</h3>
<p style="text-indent:2em;">创建完成状态：</p>
<img src="https://yeyusky.github.io/post-images/created.png" alt="" />
<img src="https://yeyusky.github.io/post-images/createdh.png" alt="" />
<p style="text-indent:2em; font-size:12px;">如上图所示，创建完成后，属性已经绑定，但是DOM未生成，所以el仍是undefined 。</p>
<h3>3、beforeMount</h3>
<p style="text-indent:2em;">挂载前状态：</p>
<img src="https://yeyusky.github.io/post-images/beforemount.png" alt="" />
<img src="https://yeyusky.github.io/post-images/beforemounth.png" alt="" />
<p style="text-indent:2em; font-size:12px;">如上图所示，挂载前的状态，el与data都已经完成了初始化。</p>
<h3>4、Mounted</h3>
<p style="text-indent:2em;">挂载结束状态：</p>
<img src="https://yeyusky.github.io/post-images/mounted.png" alt="" />
<img src="https://yeyusky.github.io/post-images/mountedh.png" alt="" />
<p style="text-indent:2em; font-size:12px;">如上图所示，挂载结束的状态，完成了挂载，app里面的{{message}}已经变成的数据。</p>
<h3>5、beforeUpdate和Updated</h3>
<p style="text-indent:2em;">更新前和更新后状态：</p>
<img src="https://yeyusky.github.io/post-images/beup.png" alt="" />
<img src="https://yeyusky.github.io/post-images/beuph.png" alt="" />
<p style="text-indent:2em; font-size:12px;">如上图所示，只有更新了数据，并且该数据已经被写在了模板中，能渲染到页面上，才会调用这两个钩子。</p>
<h3>6、beforeUpdate和Updated</h3>
<p style="text-indent:2em;">更新前和更新后状态：</p>
<img src="https://yeyusky.github.io/post-images/beup.png" alt="" />
<img src="https://yeyusky.github.io/post-images/beuph.png" alt="" />
<p style="text-indent:2em; font-size:12px;">如上图所示，只有更新了数据，并且该数据已经被写在了模板中，能渲染到页面上，才会调用这两个钩子。</p>
<h3>7、beforeDestroy和destroyed</h3>
<p style="text-indent:2em;">销毁前和销毁完成状态：</p>
<img src="https://yeyusky.github.io/post-images/destoy.png" alt="" />
<img src="https://yeyusky.github.io/post-images/destoyh.png" alt="" />
<p style="text-indent:2em; font-size:12px;">如上图所示，根据官网的说法是beforeDestroy是在实例销毁之前调用。在这一步，实例仍然完全可用。destroyed是在Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。大概就是这个样子，还需要仔细研究一下才能吃透。</p>
<h3>8、写在最后</h3>
<p style="text-indent:2em; ">具体的钩子应用我相信大家都有一丢丢疑问吧，当然我也有，所以我们要不断的探索和发现。</p>
<p>****1、beforecreate : 可以在这加个loading事件 。
<br>****2、created ：在这结束loading，还做一些初始化，实现函数自执行 .
<br>****3、mounted ： 在这发起后端请求，拿回数据，配合路由钩子做一些事情.
<br>****4、beforeDestroy： 你确认删除XX吗？
	<br>****5、destroyed ：当前组件已被删除，清空相关内容。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue学习总结--component组件]]></title>
        <id>https://yeyusky.github.io/post/vue-component</id>
        <link href="https://yeyusky.github.io/post/vue-component">
        </link>
        <updated>2019-07-02T04:41:33.000Z</updated>
        <content type="html"><![CDATA[<h1>如何引入vue？</h1>
<p style="text-indent:2em;">vue.js跟jQuery相似，所以我们要先引人vue.js，引入可以通过官网下载JS文件（这里就不做详细介绍了），如下图：</p>
<img src="https://yeyusky.github.io/post-images/yr-vue.png" alt="" />
<p style="text-indent:2em;">亦或是通过cdn的方式引入，如下图：</p>
<img src="https://yeyusky.github.io/post-images/cdnyr-vue.png" alt="" />
<p style="text-indent:2em;">再或是通过npm安装引入，如下图：</p>
<img src="https://yeyusky.github.io/post-images/npmyr-vue.png" alt="" />
<p style="text-indent:2em;">上面的都完成了，下面我们就可以来一起学习一下vue的组件，vue组件有全局组件和局部组件两种</p>
<h1>vue之全局组件</h1>
<p style="text-indent:2em;">全局组件代码如下图：</p>
<img src="https://yeyusky.github.io/post-images/qcomponent.png" alt="" />
<p style="text-indent:2em;">如果只是按照上图所示是不成功的，必须还要new一个vue实例，如下图：</p>
<img src="https://yeyusky.github.io/post-images/qcom1.png" alt="" />	
<p style="text-indent:2em;">HTML中的代码：</p>
<img src="https://yeyusky.github.io/post-images/qcom2.png" alt="" />	
<p style="text-indent:2em;">最后页面中的显示：</p>
<img src="https://yeyusky.github.io/post-images/qcom3.png" alt="" />	
<h1>vue之局部组件</h1>
<p style="text-indent:2em;">局部组件注册第一种方式：</p>
<img src="https://yeyusky.github.io/post-images/jbvue1.png" alt="" />
<p style="text-indent:2em;">局部组件注册第二种方式：</p>
<img src="https://yeyusky.github.io/post-images/jbvue2.png" alt="" />	
<img src="https://yeyusky.github.io/post-images/jbvue3.png" alt="" />
<p style="text-indent:2em;">HTML中的代码：</p>
<img src="https://yeyusky.github.io/post-images/jbvue4.png" alt="" />	
<p style="text-indent:2em;">最后页面中的显示：</p>
<img src="https://yeyusky.github.io/post-images/jbvue5.png" alt="" />	
<p style="text-indent:2em;font-size:18px;color:red; ">****前端小白初次写作，如有不足，还望指正</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[前端必走之路----CSS]]></title>
        <id>https://yeyusky.github.io/post/css-por</id>
        <link href="https://yeyusky.github.io/post/css-por">
        </link>
        <updated>2019-07-01T03:49:27.000Z</updated>
        <content type="html"><![CDATA[<p style="text-indent:2em;">前端的领域里，任何东西都离不开HTML 与 CSS。HTML与CSS基本上控制了你看到的所有东西，HTML用来定义内容而CSS负责样式与布局。</p>
<p style="text-indent:2em;">闲话少说，让我们再来熟悉一下CSS中的各个属性</p>
        <img src="https://yeyusky.github.io/post-images/totalcss.jpg" alt="" />]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://yeyusky.github.io/post/hello-gridea</id>
        <link href="https://yeyusky.github.io/post/hello-gridea">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="http://hvenotes.fehey.com/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>𝖶𝗂𝗇𝖽𝗈𝗐𝗌</strong> 或 <strong>𝖬𝖺𝖼𝖮𝖲</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>